{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  update(delta) {\n    if (this.particle.destroyed) {\n      return;\n    }\n\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.updateStrokeColor(delta);\n    this.updateOutMode(delta);\n  }\n\n  updateOpacity(delta) {\n    const particle = this.particle;\n\n    if (particle.particlesOptions.opacity.animation.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.OpacityAnimationStatus.increasing:\n          if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.OpacityAnimationStatus.decreasing:\n          if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a;\n\n    const container = this.container;\n    const particle = this.particle;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.SizeAnimationStatus.increasing:\n          if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n            particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n          } else {\n            particle.size.value += (particle.size.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.SizeAnimationStatus.decreasing:\n          if (particle.size.value <= sizeAnim.minimumValue) {\n            particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n          } else {\n            particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n          }\n\n      }\n\n      switch (sizeAnim.destroy) {\n        case Enums_1.DestroyType.max:\n          if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n\n        case Enums_1.DestroyType.min:\n          if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n      }\n\n      if (particle.size.value < 0 && !particle.destroyed) {\n        particle.size.value = 0;\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    const particle = this.particle;\n    const rotate = particle.particlesOptions.rotate;\n    const rotateAnimation = rotate.animation;\n    const speed = rotateAnimation.speed / 360 * delta.factor;\n    const max = 2 * Math.PI;\n\n    if (rotate.path) {\n      particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n    } else {\n      if (rotateAnimation.enable) {\n        switch (particle.rotateDirection) {\n          case Enums_1.RotateDirection.clockwise:\n            particle.angle += speed;\n\n            if (particle.angle > max) {\n              particle.angle -= max;\n            }\n\n            break;\n\n          case Enums_1.RotateDirection.counterClockwise:\n          default:\n            particle.angle -= speed;\n\n            if (particle.angle < 0) {\n              particle.angle += max;\n            }\n\n            break;\n        }\n      }\n    }\n  }\n\n  updateColor(delta) {\n    const particle = this.particle;\n\n    if (particle.color === undefined) {\n      return;\n    }\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.color.h > 360) {\n        particle.color.h -= 360;\n      }\n    }\n  }\n\n  updateStrokeColor(delta) {\n    const particle = this.particle;\n    const color = particle.stroke.color;\n\n    if (typeof color === \"string\" || color === undefined) {\n      return;\n    }\n\n    if (particle.strokeColor === undefined) {\n      return;\n    }\n\n    if (color.animation.enable) {\n      particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.strokeColor.h > 360) {\n        particle.strokeColor.h -= 360;\n      }\n    }\n  }\n\n  fixOutOfCanvasPosition() {\n    const container = this.container;\n    const particle = this.particle;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    const newPos = {\n      bottom: canvasSize.height + particle.size.value - particle.offset.y,\n      left: -particle.size.value - particle.offset.x,\n      right: canvasSize.width + particle.size.value + particle.offset.x,\n      top: -particle.size.value - particle.offset.y\n    };\n    const sizeValue = particle.size.value;\n    const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n    if (nextBounds.left > canvasSize.width - particle.offset.x) {\n      particle.position.x = newPos.left;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    } else if (nextBounds.right < -particle.offset.x) {\n      particle.position.x = newPos.right;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    }\n\n    if (nextBounds.top > canvasSize.height - particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.top;\n    } else if (nextBounds.bottom < -particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.bottom;\n    }\n  }\n\n  updateOutMode(delta) {\n    const container = this.container;\n    const particle = this.particle;\n\n    switch (particle.particlesOptions.move.outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n        this.updateBounce(delta);\n        break;\n\n      case Enums_1.OutMode.destroy:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          particle.destroy();\n          container.particles.remove(particle);\n          return;\n        }\n\n        break;\n\n      case Enums_1.OutMode.out:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          this.fixOutOfCanvasPosition();\n        }\n\n    }\n  }\n\n  updateBounce(delta) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (handled) {\n      return;\n    }\n\n    const outMode = particle.particlesOptions.move.outMode,\n          pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.size.value,\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n      const velocity = particle.velocity.horizontal;\n\n      if (bounds.right >= canvasSize.width && velocity > 0 || bounds.left <= 0 && velocity < 0) {\n        particle.velocity.horizontal *= -1;\n      }\n\n      const minPos = offset.x + size;\n\n      if (bounds.right >= canvasSize.width) {\n        particle.position.x = canvasSize.width - minPos;\n      } else if (bounds.left <= 0) {\n        particle.position.x = minPos;\n      }\n    }\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n      const velocity = particle.velocity.vertical;\n\n      if (bounds.bottom >= container.canvas.size.height && velocity > 0 || bounds.top <= 0 && velocity < 0) {\n        particle.velocity.vertical *= -1;\n      }\n\n      const minPos = offset.y + size;\n\n      if (bounds.bottom >= canvasSize.height) {\n        particle.position.y = canvasSize.height - minPos;\n      } else if (bounds.top <= 0) {\n        particle.position.y = minPos;\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":{"version":3,"sources":["/Users/kudy/Desktop/Face-Detectify/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Enums_1","constructor","container","particle","update","delta","destroyed","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutMode","particlesOptions","opacity","animation","enable","status","OpacityAnimationStatus","increasing","decreasing","velocity","factor","minimumValue","_a","sizeOpt","size","sizeAnim","SizeAnimationStatus","sizeValue","retina","destroy","DestroyType","max","pixelRatio","min","rotate","rotateAnimation","speed","Math","PI","path","pathAngle","atan2","vertical","horizontal","rotateDirection","RotateDirection","clockwise","angle","counterClockwise","color","undefined","h","colorVelocity","stroke","strokeColor","fixOutOfCanvasPosition","wrap","move","warp","canvasSize","canvas","newPos","bottom","height","offset","y","left","x","right","width","top","nextBounds","Utils","calculateBounds","position","random","outMode","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","isPointInside","particles","remove","out","handled","plugin","plugins","particleBounce","pos","getPosition","bounds","minPos"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Enums_1 = require(\"../../Enums\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n    }\n    update(delta) {\n        if (this.particle.destroyed) {\n            return;\n        }\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.updateStrokeColor(delta);\n        this.updateOutMode(delta);\n    }\n    updateOpacity(delta) {\n        const particle = this.particle;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.OpacityAnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.OpacityAnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a;\n        const container = this.container;\n        const particle = this.particle;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.SizeAnimationStatus.increasing:\n                    if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += (particle.size.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.SizeAnimationStatus.decreasing:\n                    if (particle.size.value <= sizeAnim.minimumValue) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        const particle = this.particle;\n        const rotate = particle.particlesOptions.rotate;\n        const rotateAnimation = rotate.animation;\n        const speed = (rotateAnimation.speed / 360) * delta.factor;\n        const max = 2 * Math.PI;\n        if (rotate.path) {\n            particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n        }\n        else {\n            if (rotateAnimation.enable) {\n                switch (particle.rotateDirection) {\n                    case Enums_1.RotateDirection.clockwise:\n                        particle.angle += speed;\n                        if (particle.angle > max) {\n                            particle.angle -= max;\n                        }\n                        break;\n                    case Enums_1.RotateDirection.counterClockwise:\n                    default:\n                        particle.angle -= speed;\n                        if (particle.angle < 0) {\n                            particle.angle += max;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    updateColor(delta) {\n        const particle = this.particle;\n        if (particle.color === undefined) {\n            return;\n        }\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.color.h > 360) {\n                particle.color.h -= 360;\n            }\n        }\n    }\n    updateStrokeColor(delta) {\n        const particle = this.particle;\n        const color = particle.stroke.color;\n        if (typeof color === \"string\" || color === undefined) {\n            return;\n        }\n        if (particle.strokeColor === undefined) {\n            return;\n        }\n        if (color.animation.enable) {\n            particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.strokeColor.h > 360) {\n                particle.strokeColor.h -= 360;\n            }\n        }\n    }\n    fixOutOfCanvasPosition() {\n        const container = this.container;\n        const particle = this.particle;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        const newPos = {\n            bottom: canvasSize.height + particle.size.value - particle.offset.y,\n            left: -particle.size.value - particle.offset.x,\n            right: canvasSize.width + particle.size.value + particle.offset.x,\n            top: -particle.size.value - particle.offset.y,\n        };\n        const sizeValue = particle.size.value;\n        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n        if (nextBounds.left > canvasSize.width - particle.offset.x) {\n            particle.position.x = newPos.left;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        else if (nextBounds.right < -particle.offset.x) {\n            particle.position.x = newPos.right;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        if (nextBounds.top > canvasSize.height - particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.top;\n        }\n        else if (nextBounds.bottom < -particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.bottom;\n        }\n    }\n    updateOutMode(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        switch (particle.particlesOptions.move.outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n                this.updateBounce(delta);\n                break;\n            case Enums_1.OutMode.destroy:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    particle.destroy();\n                    container.particles.remove(particle);\n                    return;\n                }\n                break;\n            case Enums_1.OutMode.out:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    this.fixOutOfCanvasPosition();\n                }\n        }\n    }\n    updateBounce(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const outMode = particle.particlesOptions.move.outMode, pos = particle.getPosition(), offset = particle.offset, size = particle.size.value, bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n            const velocity = particle.velocity.horizontal;\n            if ((bounds.right >= canvasSize.width && velocity > 0) || (bounds.left <= 0 && velocity < 0)) {\n                particle.velocity.horizontal *= -1;\n            }\n            const minPos = offset.x + size;\n            if (bounds.right >= canvasSize.width) {\n                particle.position.x = canvasSize.width - minPos;\n            }\n            else if (bounds.left <= 0) {\n                particle.position.x = minPos;\n            }\n        }\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n            const velocity = particle.velocity.vertical;\n            if ((bounds.bottom >= container.canvas.size.height && velocity > 0) || (bounds.top <= 0 && velocity < 0)) {\n                particle.velocity.vertical *= -1;\n            }\n            const minPos = offset.y + size;\n            if (bounds.bottom >= canvasSize.height) {\n                particle.position.y = canvasSize.height - minPos;\n            }\n            else if (bounds.top <= 0) {\n                particle.position.y = minPos;\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}