{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Linker = void 0;\n\nconst Utils_1 = require(\"../../../../Utils\");\n\nclass Linker {\n  constructor(container) {\n    this.container = container;\n  }\n\n  isEnabled(particle) {\n    return particle.particlesOptions.links.enable;\n  }\n\n  reset() {}\n\n  interact(p1) {\n    var _a;\n\n    const container = this.container;\n    const linkOpt1 = p1.particlesOptions.links;\n    const optOpacity = linkOpt1.opacity;\n    const optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;\n    const canvasSize = container.canvas.size;\n    const warp = linkOpt1.warp;\n    const pos1 = p1.getPosition();\n    const range = warp ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize) : new Utils_1.Circle(pos1.x, pos1.y, optDistance);\n    const query = container.particles.quadTree.query(range);\n\n    for (const p2 of query) {\n      const linkOpt2 = p2.particlesOptions.links;\n\n      if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id) {\n        continue;\n      }\n\n      const pos2 = p2.getPosition();\n      let distance = Utils_1.Utils.getDistance(pos1, pos2);\n\n      if (warp) {\n        if (distance > optDistance) {\n          const pos2NE = {\n            x: pos2.x - canvasSize.width,\n            y: pos2.y\n          };\n          distance = Utils_1.Utils.getDistance(pos1, pos2NE);\n\n          if (distance > optDistance) {\n            const pos2SE = {\n              x: pos2.x - canvasSize.width,\n              y: pos2.y - canvasSize.height\n            };\n            distance = Utils_1.Utils.getDistance(pos1, pos2SE);\n\n            if (distance > optDistance) {\n              const pos2SW = {\n                x: pos2.x,\n                y: pos2.y - canvasSize.height\n              };\n              distance = Utils_1.Utils.getDistance(pos1, pos2SW);\n            }\n          }\n        }\n      }\n\n      if (distance > optDistance) {\n        return;\n      }\n\n      const opacityLine = optOpacity - distance * optOpacity / optDistance;\n\n      if (opacityLine > 0) {\n        const linksOptions = p1.particlesOptions.links;\n        let linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n\n        if (!linkColor) {\n          const optColor = linksOptions.color;\n          const color = typeof optColor === \"string\" ? optColor : optColor.value;\n\n          if (color === Utils_1.Constants.randomColorValue) {\n            if (linksOptions.consent) {\n              linkColor = Utils_1.ColorUtils.colorToRgb({\n                value: color\n              });\n            } else if (linksOptions.blink) {\n              linkColor = Utils_1.Constants.randomColorValue;\n            } else {\n              linkColor = Utils_1.Constants.midColorValue;\n            }\n          } else {\n            linkColor = Utils_1.ColorUtils.colorToRgb({\n              value: color\n            });\n          }\n\n          if (linksOptions.id !== undefined) {\n            container.particles.linksColors.set(linksOptions.id, linkColor);\n          } else {\n            container.particles.linksColor = linkColor;\n          }\n        }\n\n        if (p2.links.map(t => t.destination).indexOf(p1) === -1 && p1.links.map(t => t.destination).indexOf(p2) === -1) {\n          p1.links.push({\n            destination: p2,\n            opacity: opacityLine\n          });\n        }\n      }\n    }\n  }\n\n}\n\nexports.Linker = Linker;","map":{"version":3,"sources":["/Users/kudy/Desktop/Face-Detectify/node_modules/tsparticles/dist/Core/Particle/Interactions/Particles/Linker.js"],"names":["Object","defineProperty","exports","value","Linker","Utils_1","require","constructor","container","isEnabled","particle","particlesOptions","links","enable","reset","interact","p1","_a","linkOpt1","optOpacity","opacity","optDistance","linksDistance","retina","canvasSize","canvas","size","warp","pos1","getPosition","range","CircleWarp","x","y","Circle","query","particles","quadTree","p2","linkOpt2","id","pos2","distance","Utils","getDistance","pos2NE","width","pos2SE","height","pos2SW","opacityLine","linksOptions","linkColor","undefined","linksColors","get","linksColor","optColor","color","Constants","randomColorValue","consent","ColorUtils","colorToRgb","blink","midColorValue","set","map","t","destination","indexOf","push"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Linker = void 0;\nconst Utils_1 = require(\"../../../../Utils\");\nclass Linker {\n    constructor(container) {\n        this.container = container;\n    }\n    isEnabled(particle) {\n        return particle.particlesOptions.links.enable;\n    }\n    reset() {\n    }\n    interact(p1) {\n        var _a;\n        const container = this.container;\n        const linkOpt1 = p1.particlesOptions.links;\n        const optOpacity = linkOpt1.opacity;\n        const optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;\n        const canvasSize = container.canvas.size;\n        const warp = linkOpt1.warp;\n        const pos1 = p1.getPosition();\n        const range = warp\n            ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)\n            : new Utils_1.Circle(pos1.x, pos1.y, optDistance);\n        const query = container.particles.quadTree.query(range);\n        for (const p2 of query) {\n            const linkOpt2 = p2.particlesOptions.links;\n            if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id) {\n                continue;\n            }\n            const pos2 = p2.getPosition();\n            let distance = Utils_1.Utils.getDistance(pos1, pos2);\n            if (warp) {\n                if (distance > optDistance) {\n                    const pos2NE = {\n                        x: pos2.x - canvasSize.width,\n                        y: pos2.y,\n                    };\n                    distance = Utils_1.Utils.getDistance(pos1, pos2NE);\n                    if (distance > optDistance) {\n                        const pos2SE = {\n                            x: pos2.x - canvasSize.width,\n                            y: pos2.y - canvasSize.height,\n                        };\n                        distance = Utils_1.Utils.getDistance(pos1, pos2SE);\n                        if (distance > optDistance) {\n                            const pos2SW = {\n                                x: pos2.x,\n                                y: pos2.y - canvasSize.height,\n                            };\n                            distance = Utils_1.Utils.getDistance(pos1, pos2SW);\n                        }\n                    }\n                }\n            }\n            if (distance > optDistance) {\n                return;\n            }\n            const opacityLine = optOpacity - (distance * optOpacity) / optDistance;\n            if (opacityLine > 0) {\n                const linksOptions = p1.particlesOptions.links;\n                let linkColor = linksOptions.id !== undefined\n                    ? container.particles.linksColors.get(linksOptions.id)\n                    : container.particles.linksColor;\n                if (!linkColor) {\n                    const optColor = linksOptions.color;\n                    const color = typeof optColor === \"string\" ? optColor : optColor.value;\n                    if (color === Utils_1.Constants.randomColorValue) {\n                        if (linksOptions.consent) {\n                            linkColor = Utils_1.ColorUtils.colorToRgb({\n                                value: color,\n                            });\n                        }\n                        else if (linksOptions.blink) {\n                            linkColor = Utils_1.Constants.randomColorValue;\n                        }\n                        else {\n                            linkColor = Utils_1.Constants.midColorValue;\n                        }\n                    }\n                    else {\n                        linkColor = Utils_1.ColorUtils.colorToRgb({\n                            value: color,\n                        });\n                    }\n                    if (linksOptions.id !== undefined) {\n                        container.particles.linksColors.set(linksOptions.id, linkColor);\n                    }\n                    else {\n                        container.particles.linksColor = linkColor;\n                    }\n                }\n                if (p2.links.map((t) => t.destination).indexOf(p1) === -1 &&\n                    p1.links.map((t) => t.destination).indexOf(p2) === -1) {\n                    p1.links.push({\n                        destination: p2,\n                        opacity: opacityLine,\n                    });\n                }\n            }\n        }\n    }\n}\nexports.Linker = Linker;\n"]},"metadata":{},"sourceType":"script"}